# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Config {
  """
  Collection of supported types of dataset, for example github issues, jira projects, etc...
  """
  datasets: Datasets!

  """A single dataset element"""
  dataset(id: String!): Dataset!
}

type Dataset {
  id: ID!

  """Key representing the dataset in the tool configuration"""
  key: String!

  """Displayable name of the dataset"""
  name: String

  """Platform of the source data (GitHub, CircleCi, Jira, ...)"""
  platform: String

  """Elasticsearch index containing the dataset"""
  index: String

  """Is the dataset active or not"""
  active: Boolean
}

type Datasets {
  """Total count of elements"""
  totalCount: Float!

  """A list of available datasets"""
  nodes: [Dataset!]!
}

type GithubPullrequests {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubPullrequestsData!

  """Access to configuration values and metadata"""
  config: GithubPullrequestsConfig!
}

type GithubPullrequestsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: ItemSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): PullrequestsItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): PullRequest

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): PullrequestsAggregationConnection!

  """Return aggregations (facets)"""
  metrics(
    """
    Numberic field to filter on, using the node as the root object (examples: labels.totalCount, comments.totalCount)
    """
    field: String!
  ): DataMetrics!

  """Return a matrix aggregation per week and field"""
  activity(
    """Field to be used for the aggregations (for example: repository.name)"""
    field: String!

    """Date field to be used for the aggregation (for example: ClosedAt)"""
    dateField: String!
  ): DataPrActivity!
}

input ItemSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  asc
  desc
}

type GithubPullrequestsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type ConfigAggregation {
  id: ID!

  """Actual field that can be aggregated upon"""
  field: String!

  """Type of aggregation (term, date, ...)"""
  facetType: String

  """Displayable name for the aggregation"""
  name: String

  """Value to display if field is null (or _EMPTY_)"""
  nullValue: String

  """Stringified filter to be applied if user clicks on nullValue"""
  nullFilter: String

  """Should the aggregation be displayed by default"""
  default: Boolean
}

type ConfigAggregations {
  """Total count of elements"""
  totalCount: Float!

  """A list of available datasets"""
  nodes: [ConfigAggregation!]!
}

type ConfigTableColumns {
  id: ID!

  """Displayable name for the column"""
  name: String

  """Field used to fetch the column content"""
  field: String

  """If the field is an array, the object index to use to fetch content"""
  subfield: String

  """Type of field being returned (date, string, boolean, url, array, ...)"""
  fieldType: String

  """If the field is an array of objects, path to the node to be used"""
  fieldNode: String

  """Field to sort upon for the column (could be different)"""
  sortField: String

  """Should the column be sortable"""
  sortable: Boolean

  """Link attached to the field"""
  linkField: String

  """Should the column be displayed by default"""
  default: Boolean
}

type ConfigTable {
  """The type of item available in the table"""
  itemsType: String

  """The default sort field"""
  defaultSortField: String

  """A list of available columns"""
  columns: [ConfigTableColumns!]!
}

type RepositoryOwner {
  id: ID!

  """The username of the actor."""
  login: String!

  """The HTTP URL for this repository."""
  url: String!
}

type BranchProtectionRule {
  id: ID!

  """Identifies the primary key from the database."""
  databaseId: Float!

  """Can admins overwrite branch protection."""
  isAdminEnforced: Boolean!

  """Identifies the protection rule pattern."""
  pattern: String

  """Number of approving reviews required to update matching branches."""
  requiredApprovingReviewCount: Float

  """
  List of required status check contexts that must pass for commits to be accepted to matching branches.
  """
  requiredStatusCheckContexts: String

  """Are approving reviews required to update matching branches."""
  requiresApprovingReviews: Boolean!

  """Are reviews from code owners required to update matching branches."""
  requiresCodeOwnerReviews: Boolean!

  """Are commits required to be signed"""
  requiresCommitSignatures: Boolean!

  """Are status checks required to update matching branches."""
  requiresStatusChecks: Boolean!

  """Are branches required to be up to date before merging."""
  requiresStrictStatusChecks: Boolean!

  """Is pushing to matching branches restricted."""
  restrictsPushes: Boolean!

  """Is dismissal of pull request reviews restricted."""
  restrictsReviewDismissals: Boolean!
}

type BranchProtectionRuleEdge {
  """The item at the end of the edge."""
  node: BranchProtectionRule!
}

type BranchProtectionRuleConnection {
  """A list of edges."""
  edges: [BranchProtectionRuleEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type CodeOfConduct {
  id: ID!

  """The key for the Code of Conduct"""
  key: String

  """The formal name of the Code of Conduct"""
  name: String!

  """The body of the Code of Conduct"""
  body: String!

  """The HTTP URL for this Code of Conduct"""
  url: String!
}

type CommitEdge {
  """The item at the end of the edge."""
  node: Commit!
}

type CommitHistoryConnection {
  """A list of edges."""
  edges: [CommitEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type GitActor {
  """A URL pointing to the actor public avatar."""
  avatarUrl: String

  """The timestamp of the Git action (authoring or committing)"""
  date: String

  """The email in the Git commit."""
  email: String

  """The name in the Git commit."""
  name: String

  """
  The GitHub user corresponding to the email field. Null if no such user exists.
  """
  user: User
}

type Commit {
  id: ID!

  """The datetime when this commit was pushed."""
  pushedDate: String

  """The Git commit message headline"""
  messageHeadline: String

  """
  The linear commit history starting from (and including) this commit, in the same order as `git log`
  """
  history: CommitHistoryConnection

  """Authorship details of the commit."""
  author: GitActor
}

type Ref {
  id: ID!

  """The ref name."""
  name: String

  """The ref prefix, such as `refs/heads/` or`refs/tags/`."""
  prefix: String

  """The commit the ref points to"""
  target: Commit
}

type ReviewRequest {
  """The actor."""
  requestedReviewer: User
}

type ReviewRequestEdge {
  """The item at the end of the edge."""
  node: ReviewRequest!
}

type ReviewRequestConnection {
  """A list of edges."""
  edges: [ReviewRequestEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type PullrequestEdge {
  """The item at the end of the edge."""
  node: PullRequest!
}

type PullRequestConnection {
  """A list of edges."""
  edges: [PullrequestEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Label {
  id: ID!

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """Identifies the date and time when the object was last updated."""
  updatedAt: String!

  """Identifies the label color."""
  color: String!

  """Identifies the label name."""
  name: String!

  """Is this a default label"""
  isDefault: Boolean

  """A brief description of this label."""
  description: String

  """The repository where the PR is located"""
  repository: Repository!

  """A list of issues that have been opened in the repository."""
  issues: IssueConnection

  """A list of pull requests that have been opened in the repository."""
  pullRequests: PullRequestConnection

  """The HTTP URL for this PR."""
  url: String
}

type LabelEdge {
  """The item at the end of the edge."""
  node: Label!
}

type LabelConnection {
  """A list of edges."""
  edges: [LabelEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Comments {
  id: ID!
}

type CommentEdge {
  """The item at the end of the edge."""
  node: Comments!
}

type CommentConnection {
  """A list of edges."""
  edges: [CommentEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type ProjectColumn {
  id: ID!

  """Identifies the primary key from the database."""
  databaseId: Float!

  """Identifies the object name."""
  name: String!

  """List of associated project cards."""
  cards: ProjectCardConnection!
}

type ProjectColumnEdge {
  """The item at the end of the edge."""
  node: ProjectColumn!
}

type ProjectColumnConnection {
  """A list of edges."""
  edges: [ProjectColumnEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Organization {
  id: ID!

  """Identifies the date and time when the object was created."""
  createdAt: String

  """ The organization login name."""
  login: String!

  """A URL pointing to the actor public avatar."""
  avatarUrl: String

  """The HTTP URL for this actor."""
  url: String!

  """The organization public profile name."""
  name: String

  """The organization public profile name."""
  email: String

  """The organization public profile URL."""
  websiteUrl: String
}

type Actor {
  id: ID!

  """A URL pointing to the actor public avatar."""
  avatarUrl: String

  """The name of the actor."""
  name: String

  """The company of the actor."""
  company: String

  """The username of the actor."""
  login: String!

  """The HTTP URL for this actor."""
  url: String!
}

type Project {
  id: ID!

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """The actor who authored the comment.a"""
  creator: Actor!

  """Is the project attached to an organization, a repository or a user"""
  projectLevel: String!

  """Identifies the date and time when the object was created."""
  closedAt: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: String!

  """Identifies the primary key from the database."""
  databaseId: Float!

  """ Identifies the project number."""
  number: String!

  """The HTTP URL for this PR."""
  url: String!

  """Identifies the object name."""
  name: String!

  """Identifies the object state."""
  state: String

  """Identifies the object body."""
  body: String

  """List of associated project columns."""
  columns: ProjectColumnConnection!

  """List of pending project cards."""
  pendingCards: ProjectCardConnection!

  """The repository where the project is located"""
  repository: Repository

  """The organization where the project is located"""
  organization: Organization!
}

type ProjectCard {
  id: ID!

  """The project attached to the card"""
  project: Project

  """The project attached to the card"""
  column: ProjectColumn
}

type ProjectCardEdge {
  """The item at the end of the edge."""
  node: ProjectCard!
}

type ProjectCardConnection {
  """A list of edges."""
  edges: [ProjectCardEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Milestone {
  id: ID!

  """Identifies the date and time when the object was created."""
  closedAt: String

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """Description of the Milestone"""
  description: String

  """When is the milestone due"""
  dueOn: String

  """When is the milestone due"""
  issues: IssueConnection

  """A list of pull requests that have been opened in the repository."""
  pullRequests: PullRequestConnection

  """ Identifies the issue number."""
  number: String!

  """Identifies the state of the PR."""
  state: String!

  """Identifies the object title."""
  title: String!

  """Identifies the date and time when the object was last updated."""
  updatedAt: String!

  """The HTTP URL for this PR."""
  url: String!

  """The repository where the PR is located"""
  repository: Repository!
}

type PullRequestReview {
  """The actor."""
  author: Actor!

  """The review state"""
  state: String!
}

type PullRequestReviewEdge {
  """The item at the end of the edge."""
  node: PullRequestReview!
}

type PullRequestReviewConnection {
  """A list of edges."""
  edges: [PullRequestReviewEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Issue {
  id: ID!

  """A list of Users assigned to this object."""
  assignees: UserConnection

  """A list of Review Requests assigned to this object."""
  reviewRequests: ReviewRequestConnection

  """A list of Reviews assigned to this object."""
  reviews: PullRequestReviewConnection

  """The actor who authored the comment.a"""
  author: Actor

  """Identifies the body of the PR."""
  body: String

  """Identifies the date and time when the object was created."""
  closedAt: String

  """A list of comments"""
  comments: CommentConnection

  """Identifies the date and time when the object was created."""
  createdAt: String

  """Identifies the primary key from the database."""
  databaseId: Float

  """Story points assocaited with the issue"""
  points: Float

  """A list of labels associated with the object."""
  labels: LabelConnection

  """A list of labels associated with the object."""
  milestone: Milestone

  """ Identifies the issue number."""
  number: String

  """A list of Users that are participating in the conversation."""
  participants: UserConnection

  """List of associated project cards."""
  projectCards: ProjectCardConnection

  """Identifies the date and time when the object was last updated."""
  updatedAt: String

  """The repository where the PR is located"""
  repository: Repository

  """Identifies the object title."""
  title: String

  """Identifies the state of the PR."""
  state: String

  """The HTTP URL for this PR."""
  url: String
}

type IssueEdge {
  """The item at the end of the edge."""
  node: Issue!
}

type IssueConnection {
  """A list of edges."""
  edges: [IssueEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Language {
  id: ID!

  """Identifies the label color."""
  color: String!

  """Identifies the label name."""
  name: String!
}

type LanguageEdge {
  """The item at the end of the edge."""
  node: Language!
}

type LanguageConnection {
  """A list of edges."""
  edges: [LanguageEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type License {
  id: ID!

  """The lowercased SPDX ID of the license"""
  key: String!

  """Identifies the label name."""
  name: String!

  """Customary short name if applicable (e.g, GPLv3)"""
  nickname: String!

  """Short identifier specified by <https://spdx.org/licenses>"""
  spdxId: String

  """URL to the license on <https://choosealicense.com>"""
  url: String
}

type MilestoneEdge {
  """The item at the end of the edge."""
  node: Milestone!
}

type MilestoneConnection {
  """A list of edges."""
  edges: [MilestoneEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type ProjectEdge {
  """The item at the end of the edge."""
  node: Project!
}

type ProjectConnection {
  """A list of edges."""
  edges: [ProjectEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type RefEdge {
  """The item at the end of the edge."""
  node: Ref!
}

type RefConnection {
  """A list of edges."""
  edges: [RefEdge!]

  """Identifies the total count of items in the connection."""
  totalCount: Int
}

type Release {
  id: ID!

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """Identifies the date and time when the object was last updated."""
  updatedAt: String!

  """Identifies the date and time when the object was published."""
  publishedAt: String!

  """Name of the release"""
  name: String

  """Tag Name of the release"""
  tagName: String!

  """Description of the release"""
  description: String!

  """The HTTP URL for this PR."""
  url: String!

  """Indicates if the release is a draft"""
  isDraft: Boolean

  """Indicates if the release is a pre-release"""
  isPrerelease: Boolean

  """The actor who authored the comment."""
  author: Actor!

  """The repository where the PR is located"""
  repository: Repository!
}

type ReleaseEdge {
  """The item at the end of the edge."""
  node: Release!
}

type ReleaseConnection {
  """A list of edges."""
  edges: [ReleaseEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Topic {
  id: ID!

  """Identifies the label name."""
  name: String!
}

type RepositoryTopic {
  id: ID!

  """The topic."""
  topic: Topic!

  """The HTTP URL for this repository-topic."""
  url: String!
}

type RepositoryTopicEdge {
  """The item at the end of the edge."""
  node: RepositoryTopic!
}

type RepositoryTopicConnection {
  """A list of edges."""
  edges: [RepositoryTopicEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type StargazerConnection {
  """A list of edges."""
  edges: [ReleaseEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type SecurityAdvisory {
  id: ID!

  """When the advisory was published"""
  publishedAt: String!

  """The organization that originated the advisory"""
  origin: String!

  """A short plaintext summary of the advisory"""
  summary: String!

  """This is a long plaintext description of the advisory"""
  description: String!
  severity: SecurityAdvisorySeverity!

  """The GitHub Security Advisory ID"""
  ghsaId: String!

  """The permalink for the advisory"""
  permalink: String
}

"""The severity of the advisory"""
enum SecurityAdvisorySeverity {
  CRITICAL
  HIGH
  LOW
  MODERATE
}

type SecurityAdvisoryPackageVersion {
  """The package name or version"""
  identifier: String!
}

type SecurityAdvisoryPackage {
  """The ecosystem the package belongs to, e.g. RUBYGEMS, NPM"""
  name: String!

  """The organization that originated the advisory"""
  ecosystem: SecurityAdvisoryEcosystem!
}

"""The possible ecosystems of a security vulnerability package."""
enum SecurityAdvisoryEcosystem {
  COMPOSER
  MAVEN
  NPM
  NUGET
  PIP
  RUBYGEMS
}

type SecurityVulnerability {
  """When the vulnerability was last updated"""
  updatedAt: String!

  """The Advisory associated with this Vulnerability"""
  advisory: SecurityAdvisory!

  """When was the alert dimissed?"""
  firstPatchedVersion: SecurityAdvisoryPackageVersion

  """The user who dismissed the alert"""
  package: SecurityAdvisoryPackage

  """The severity of the vulnerability within this package"""
  severity: SecurityAdvisorySeverity

  """A string that describes the vulnerable package versions."""
  vulnerableVersionRange: String!
}

type RepositoryVulnerabilityAlert {
  id: ID!

  """Identifies the date and time when the object was created"""
  createdAt: String!

  """The reason the alert was dismissed"""
  dismissReason: String

  """When was the alert dimissed?"""
  dismissedAt: String

  """The user who dismissed the alert"""
  dismisser: User

  """The repository where the alert is located"""
  repository: Repository!

  """The vulnerable manifest path"""
  vulnerableManifestPath: String!

  """The vulnerable manifest filename"""
  vulnerableManifestFilename: String!

  """The vulnerable requirements"""
  vulnerableRequirements: String!

  """The vulnerable requirements"""
  securityVulnerability: SecurityVulnerability!
}

type RepositoryVulnerabilityAlertEdge {
  """The item at the end of the edge."""
  node: RepositoryVulnerabilityAlert!
}

type RepositoryVulnerabilityAlertConnection {
  """A list of edges."""
  edges: [RepositoryVulnerabilityAlertEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Repository {
  id: ID!

  """Identifies the primary key from the database."""
  databaseId: Float

  """The name of the repository."""
  name: String

  """The repository name with owner."""
  nameWithOwner: String

  """The HTTP URL for this repository."""
  url: String!

  """The User owner of the repository."""
  owner: RepositoryOwner!

  """The User owner of the repository."""
  branchProtectionRules: BranchProtectionRuleConnection

  """The User owner of the repository."""
  codeOfConduct: CodeOfConduct

  """Identifies the date and time when the object was created."""
  createdAt: String

  """Identifies the date and time when the object was starred by a user."""
  starredAt: String

  """The Ref associated with the repository default branch."""
  defaultBranchRef: Ref

  """The description of the repository."""
  description: String

  """The number of kilobytes this repository occupies on disk."""
  diskUsage: Int

  """
  Returns how many forks there are of this repository in the whole network.
  """
  forkCount: Int

  """Indicates if the repository has issues feature enabled."""
  hasIssuesEnabled: Boolean

  """Indicates if the repository has projects feature enabled."""
  hasProjectsEnabled: Boolean

  """Indicates if the repository has wiki feature enabled."""
  hasWikiEnabled: Boolean

  """Indicates if the repository is unmaintained."""
  isArchived: Boolean

  """Returns whether or not this repository disabled."""
  isDisabled: Boolean

  """Identifies if the repository is a fork."""
  isFork: Boolean

  """Indicates if the repository has been locked or not."""
  isLocked: Boolean

  """Identifies if the repository is a mirror."""
  isMirror: Boolean

  """Identifies if the repository is private."""
  isPrivate: Boolean

  """
  Identifies if the repository is a template that can be used to generate new repositories.
  """
  isTemplate: Boolean

  """A list of issues that have been opened in the repository."""
  issues: IssueConnection

  """A list of labels associated with the repository."""
  labels: LabelConnection

  """A list of labels associated with the repository."""
  languages: LanguageConnection

  """The license associated with the repository"""
  licenseInfo: License

  """A list of milestones associated with the repository."""
  milestones: MilestoneConnection

  """A list of milestones associated with the repository."""
  projects: ProjectConnection

  """The primary language of the repository code."""
  primaryLanguage: Language

  """A list of pull requests that have been opened in the repository."""
  pullRequests: PullRequestConnection

  """Identifies when the repository was last pushed to."""
  pushedAt: String

  """Whether or not rebase-merging is enabled on this repository."""
  rebaseMergeAllowed: Boolean

  """Whether or not rebase-merging is enabled on this repository."""
  refs: RefConnection

  """Link to the ref containing recent commits to master"""
  recentCommitsMaster: Ref

  """A list of pull requests that have been opened in the repository."""
  releases: ReleaseConnection

  """A list of applied repository-topic associations for this repository."""
  repositoryTopics: RepositoryTopicConnection

  """Whether or not squash-merging is enabled on this repository."""
  squashMergeAllowed: Boolean

  """Number of commits pushed to master during the current year (up to 10)"""
  currentYearMasterCommits: Float

  """A list of users who have starred this starrable."""
  stargazers: StargazerConnection

  """The repository from which this repository was generated, if any."""
  templateRepository: Repository

  """Identifies the date and time when the object was last updated."""
  updatedAt: String

  """A list of vulnerability alerts that are on this repository."""
  vulnerabilityAlerts: RepositoryVulnerabilityAlertConnection

  """A list of vulnerability alerts that are on this repository."""
  watchers: UserConnection
}

type Follower {
  id: ID!
}

type FollowerEdge {
  """The item at the end of the edge."""
  node: Follower!
}

type FollowerConnection {
  """A list of edges."""
  edges: [FollowerEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type FollowingConnection {
  """A list of edges."""
  edges: [FollowerEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type OrganizationEdge {
  """The item at the end of the edge."""
  node: Organization!
}

type OrganizationConnection {
  """A list of edges."""
  edges: [OrganizationEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type RepositoryEdge {
  """The item at the end of the edge."""
  node: Repository!
}

type RepositoryConnection {
  """A list of edges."""
  edges: [RepositoryEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type User {
  id: ID!

  """Identifies the date and time when the object was created."""
  createdAt: String

  """The username of the actor."""
  login: String

  """The user public profile company.."""
  company: String

  """A URL pointing to the actor public avatar."""
  avatarUrl: String

  """The HTTP URL for this actor."""
  url: String

  """The user public profile name."""
  name: String

  """If Watcher or Stargazer, the target repository"""
  repository: Repository

  """If Watcher or Stargazer, the data type (watchers or stargazers)"""
  dataType: String

  """If Stargazer, the date and time when an object was last starred."""
  lastStarredAt: String

  """Whether or not this user is a GitHub employee."""
  isEmployee: Boolean

  """Whether or not the user has marked themselves as for hire."""
  isHireable: Boolean

  """Whether or not this user is a GitHub Developer Program member."""
  isDeveloperProgramMember: Boolean

  """
  Whether or not this user is a participant in the GitHub Campus Experts Program.
  """
  isCampusExpert: Boolean

  """
  Whether or not this user is a participant in the GitHub Security Bug Bounty.
  """
  isBountyHunter: Boolean

  """A URL pointing to the user public website/ blog."""
  websiteUrl: Boolean

  """A list of users the given user is followed by."""
  followers: FollowerConnection

  """A list of users the given user is following."""
  following: FollowingConnection

  """A list of organizations the given user is a member of."""
  organizations: OrganizationConnection

  """A list of repositories watched or starred by the user"""
  repositories: RepositoryConnection
}

type UserEdge {
  """The item at the end of the edge."""
  node: User!
}

type UserConnection {
  """A list of edges."""
  edges: [UserEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type PullRequest {
  id: ID!

  """A list of Users assigned to this object."""
  assignees: UserConnection

  """A list of Review Requests assigned to this object."""
  reviewRequests: ReviewRequestConnection

  """A list of Reviews assigned to this object."""
  reviews: PullRequestReviewConnection

  """The actor who authored the comment."""
  author: Actor!

  """Identifies the body of the PR."""
  body: String!

  """Identifies the date and time when the object was created."""
  closedAt: String

  """A list of comments"""
  comments: CommentConnection!

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """Identifies the primary key from the database."""
  databaseId: Float!

  """A list of labels associated with the object."""
  labels: LabelConnection

  """A list of labels associated with the object."""
  milestone: Milestone

  """ Identifies the issue number."""
  number: String!

  """A list of Users that are participating in the conversation."""
  participants: UserConnection!

  """List of associated project cards."""
  projectCards: ProjectCardConnection!

  """Identifies the date and time when the object was last updated."""
  updatedAt: String!

  """The repository where the PR is located"""
  repository: Repository!

  """Identifies the object title."""
  title: String!

  """Identifies the state of the PR."""
  state: String!

  """The HTTP URL for this PR."""
  url: String!
}

type PullrequestsItemConnection {
  nodes: [PullRequest!]
  totalCount: Int!
}

type AggregationBucket {
  """The Bucket key"""
  key: String!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The number of elements in the bucket"""
  docCount: Float

  """The count associated with the bucket"""
  count: Float

  """
  Metadata returned based on the aggOptions parameter, it allows additional fields to be returned
  """
  metadata: String

  """Sum value of all sumField in the date histogram"""
  sum: Float

  """Avg value of all avgField in the date histogram"""
  avg: Float

  """Count of documents within a moving aggregation"""
  moving: Float
}

type PullrequestsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type DataMetrics {
  """The filed that was aggregated on"""
  field: String!

  """Minimum value for the current query"""
  min: Float!

  """Maximum value for the current query"""
  max: Float!

  """Overall minimum value (current query with field excluded)"""
  overallMin: Float!

  """Overall maximum value (current query with field excluded)"""
  overallMax: Float!
}

type BucketWeek {
  """First day of the week"""
  weekStart: String!

  """The number of documents that week"""
  docCount: Float!
}

type ActivityBucket {
  """The Bucket key"""
  key: String!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The number of elements in the bucket"""
  docCount: Float!

  """Weeks of activity"""
  weeks: [BucketWeek!]!
}

type DataPrActivity {
  """The filed that was aggregated on"""
  field: String!

  """A list of aggregation buckets"""
  buckets: [ActivityBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromWeekStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toWeekStart: String!
}

type GithubVulnerabilities {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubVulnerabilitiesData!

  """Access to configuration values and metadata"""
  config: GithubVulnerabilitiesConfig!
}

type GithubVulnerabilitiesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: Sortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): VulnerabilityConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): RepositoryVulnerabilityAlert!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): VulnerabilitiesAggregationConnection!
}

input Sortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubVulnerabilitiesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type VulnerabilityConnection {
  nodes: [RepositoryVulnerabilityAlert!]
  totalCount: Int!
}

type VulnerabilitiesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubRepositories {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubRepositoriesData!

  """Access to configuration values and metadata"""
  config: GithubRepositoriesConfig!
}

type GithubRepositoriesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: RepositoriesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataRepositoryConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): RepositoryVulnerabilityAlert!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): RepositoriesAggregationConnection!
}

input RepositoriesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubRepositoriesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type DataRepositoryConnection {
  nodes: [Repository!]
  totalCount: Int!
}

type RepositoriesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubWatchers {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubWatchersData!

  """Access to configuration values and metadata"""
  config: GithubWatchersConfig!
}

type GithubWatchersData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: WatchersSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): WatcherConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): User!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): WatchersAggregationConnection!
}

input WatchersSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubWatchersConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type WatcherConnection {
  nodes: [User!]
  totalCount: Int!
}

type WatchersAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubLabels {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubLabelsData!

  """Access to configuration values and metadata"""
  config: GithubLabelsConfig!
}

type GithubLabelsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: LabelsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataLabelConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): Label!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): LabelsAggregationConnection!
}

input LabelsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubLabelsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type DataLabelConnection {
  nodes: [Label!]
  totalCount: Int!
}

type LabelsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubMilestones {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubMilestonesData!

  """Access to configuration values and metadata"""
  config: GithubMilestonesConfig!
}

type GithubMilestonesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: MilestonesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataMilestoneConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): Milestone!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): MilestonesAggregationConnection!
}

input MilestonesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubMilestonesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type DataMilestoneConnection {
  nodes: [Milestone!]
  totalCount: Int!
}

type MilestonesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubProjects {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubProjectsData!

  """Access to configuration values and metadata"""
  config: GithubProjectsConfig!
}

type GithubProjectsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: ProjectsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataProjectConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): Project!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): ProjectsAggregationConnection!
}

input ProjectsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubProjectsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type DataProjectConnection {
  nodes: [Project!]
  totalCount: Int!
}

type ProjectsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubReleases {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubReleasesData!

  """Access to configuration values and metadata"""
  config: GithubReleasesConfig!
}

type GithubReleasesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: ReleasesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataReleaseConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): Release!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): ReleasesAggregationConnection!
}

input ReleasesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubReleasesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type DataReleaseConnection {
  nodes: [Release!]
  totalCount: Int!
}

type ReleasesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type GithubIssues {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubIssuesData!

  """Access to configuration values and metadata"""
  config: GithubIssuesConfig!
}

type GithubIssuesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: IssueSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): IssuesItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): Issue

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): IssuesAggregationConnection!

  """Return aggregations (facets)"""
  metrics(
    """
    Numberic field to filter on, using the node as the root object (examples: labels.totalCount, comments.totalCount)
    """
    field: String!
  ): IssueMetrics!

  """Return a list of projects matching the query"""
  projects: IssueProjects!

  """Return a list of milestones matching the query"""
  milestones: IssueMilestones!

  """Return velocity metrics"""
  velocity(
    """ID of an issue to be used to gather assignees and build team."""
    team: String = "default"

    """The dataset window to use for calculations"""
    window: Float = 53

    """
    Number of elements to be used for calculating the moving average, default is 4
    """
    moving: Float = 4

    """
    Interval to run the aggregation on (week, day, ...). See: https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html
    """
    interval: String = "week"
  ): VelocityConnection!

  """Return a matrix aggregation per week and field"""
  matrix(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Field to be used for the aggregations (for example: repository.name)"""
    field: String!

    """Date field to be used for the aggregation (for example: ClosedAt)"""
    dateField: String!
  ): MatrixConnection!

  """Return the networked view from a starting set of nodes"""
  network(
    """Root nodes to be used as starting point for the network graph"""
    rootNodes: [String!]!
  ): IssueNetwork!
}

input IssueSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type VelocityConnection {
  """Assignees used to calculate velocity"""
  assignees: [User!]!

  """Veloticy Weeks"""
  items: [VelocityItem!]!

  """Current Velocity data"""
  current: VelocityItem
}

type VelocityItem {
  """Start"""
  date: String!

  """Velocity data calculated using document counts"""
  issues: VelocityMetric!

  """Velocity data calculated using document points"""
  points: VelocityMetric!
}

type VelocityMetric {
  """Sum of elements"""
  sum: Float

  """Moving average"""
  moving: Float
}

type MatrixConnection {
  """Current Velocity data"""
  field: String

  """A list of aggregation buckets"""
  buckets: [IssueActivityBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromWeekStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toWeekStart: String!
}

type GithubIssuesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type IssuesItemConnection {
  nodes: [Issue!]
  totalCount: Int!
}

type IssuesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type IssueMetrics {
  """The filed that was aggregated on"""
  field: String!

  """Minimum value for the current query"""
  min: Float

  """Maximum value for the current query"""
  max: Float

  """Sum of all fields in the current query"""
  sum: Float!

  """Overall minimum value (current query with field excluded)"""
  overallMin: Float

  """Overall maximum value (current query with field excluded)"""
  overallMax: Float
}

type IssueMilestones {
  nodes: [Milestone!]
  totalCount: Int!
}

type IssueProjects {
  nodes: [Project!]
  totalCount: Int!
}

type IssueBucketWeek {
  """First day of the week"""
  weekStart: String!

  """The number of documents that week"""
  docCount: Float!

  """The number of points that week"""
  sum: Float
}

type IssueActivityBucket {
  """The Bucket key"""
  key: String!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The number of elements in the bucket"""
  docCount: Float!

  """The number of points in the bucket"""
  sum: Float

  """Weeks of activity"""
  weeks: [IssueBucketWeek!]!
}

type IssueNetworkNodeData {
  id: ID!

  """A list of Users assigned to this object."""
  assignees: UserConnection

  """A list of Review Requests assigned to this object."""
  reviewRequests: ReviewRequestConnection

  """A list of Reviews assigned to this object."""
  reviews: PullRequestReviewConnection

  """The actor who authored the comment.a"""
  author: Actor

  """Identifies the body of the PR."""
  body: String

  """Identifies the date and time when the object was created."""
  closedAt: String

  """A list of comments"""
  comments: CommentConnection

  """Identifies the date and time when the object was created."""
  createdAt: String

  """Identifies the primary key from the database."""
  databaseId: Float

  """Story points assocaited with the issue"""
  points: Float

  """A list of labels associated with the object."""
  labels: LabelConnection

  """A list of labels associated with the object."""
  milestone: Milestone

  """Issue or PR number"""
  number: Int

  """A list of Users that are participating in the conversation."""
  participants: UserConnection

  """List of associated project cards."""
  projectCards: ProjectCardConnection

  """Identifies the date and time when the object was last updated."""
  updatedAt: String

  """The repository where the PR is located"""
  repository: Repository

  """Title of the node"""
  title: String

  """State of the node"""
  state: String

  """The HTTP URL for this PR."""
  url: String

  """If the node is an edge, target is the target id of the edge element"""
  target: String

  """If the node is an edge, source is the source id of the edge element"""
  source: String

  """Distance in the tree"""
  distance: Int

  """Is this node data partial?"""
  partial: Boolean

  """Type of the node (Issue or PR)"""
  typename: String
}

type IssueNetworkNode {
  id: ID

  """Cytoscape group (either nodes or edges"""
  group: String

  """Cytoscape node label"""
  label: String

  """Cytoscape node data"""
  data: IssueNetworkNodeData
}

type IssueNetwork {
  nodes: [IssueNetworkNode!]
  totalCount: Int!

  """Time it took for ZenCrepes API to process the request (in ms)"""
  processTime: Int

  """Source used for the root nodes (query or selected Ids)"""
  source: String
}

type GithubMavenPoms {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): GithubMavenPomsData!

  """Access to configuration values and metadata"""
  config: GithubMavenPomsConfig!
}

type GithubMavenPomsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: MavenPomsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataMavenPomConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): MavenPom!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): MavenPomsAggregationConnection!
}

input MavenPomsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type GithubMavenPomsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type MavenPomContentParent {
  """Version"""
  version: String

  """Artifact ID"""
  artifactId: String

  """Group ID"""
  groupId: String
}

type MavenPomContent {
  """Version"""
  version: String

  """Artifact ID"""
  artifactId: String

  """Name"""
  name: String

  """Description"""
  description: String

  """Parent detailed in the pom file"""
  parent: MavenPomContentParent
}

type MavenPom {
  id: ID!

  """Identifies the primary key from the database."""
  databaseId: Float

  """The name of the repository."""
  name: String

  """Content of the POM file"""
  pom: MavenPomContent

  """The repository name with owner."""
  nameWithOwner: String

  """The HTTP URL for this repository."""
  url: String!

  """The User owner of the repository."""
  owner: RepositoryOwner!

  """Identifies the date and time when the object was created."""
  createdAt: String

  """The Ref associated with the repository default branch."""
  defaultBranchRef: Ref

  """The description of the repository."""
  description: String

  """Indicates if the repository is unmaintained."""
  isArchived: Boolean

  """Returns whether or not this repository disabled."""
  isDisabled: Boolean

  """Identifies if the repository is a fork."""
  isFork: Boolean

  """Identifies if the repository contains a pom file"""
  hasPom: Boolean

  """Identifies if the repository pom file has a parent"""
  hasParent: Boolean

  """Identifies when the repository was last pushed to."""
  pushedAt: String

  """Link to the ref containing recent commits to master"""
  lastCommitMainBranch: Commit

  """A list of applied repository-topic associations for this repository."""
  repositoryTopics: RepositoryTopicConnection

  """Identifies the date and time when the object was last updated."""
  updatedAt: String
}

type DataMavenPomConnection {
  nodes: [MavenPom!]
  totalCount: Int!
}

type MavenPomsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type JiraIssues {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): JiraIssuesData!

  """Access to configuration values and metadata"""
  config: JiraIssuesConfig!
}

type JiraIssuesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: JiraIssuesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): JiraIssueItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): JiraIssue!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): JiraIssuesAggregationConnection!

  """Return a matrix aggregation per week and field"""
  matrix(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Field to be used for the aggregations (for example: repository.name)"""
    field: String!

    """Date field to be used for the aggregation (for example: ClosedAt)"""
    dateField: String!
  ): JiraMatrixConnection!
}

input JiraIssuesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type JiraMatrixConnection {
  """Current Velocity data"""
  field: String

  """A list of aggregation buckets"""
  buckets: [JiraIssueActivityBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromWeekStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toWeekStart: String!
}

type JiraIssuesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type JiraAvatarUrls {
  """Avatar URL, 16x16 pixels"""
  xsmall: String

  """Avatar URL, 24x24 pixels"""
  small: String

  """Avatar URL, 32x32 pixels"""
  medium: String

  """Avatar URL, 48x48 pixels"""
  large: String
}

type JiraUser {
  """Jira Key"""
  key: String!

  """Whether the assignee account is active or not"""
  active: Boolean!

  """The assignee avatar URL"""
  avatarUrls: JiraAvatarUrls!

  """Identifies the assignee display name"""
  displayName: String!

  """Identifies the assignee display email address"""
  emailAddress: String!

  """The assignee name"""
  name: String

  """The assignee timezone"""
  timeZone: String
}

type JiraServer {
  """Jira Server name"""
  name: String!

  """URL to reach Jira server host"""
  host: String!
}

type JiraStatusCategory {
  id: ID!

  """Key of the category"""
  key: String!

  """Name of the color (non hex)"""
  colorName: String!

  """Category name"""
  name: String!
}

type JiraStatus {
  id: ID!

  """Status description"""
  description: String!

  """URL to the status icon"""
  iconUrl: String!

  """Status name"""
  name: String!

  """Status category"""
  statusCategory: JiraStatusCategory!
}

type JiraProjectCategory {
  id: ID!

  """Description of the category"""
  description: String!

  """Name of the category"""
  name: String!
}

type JiraProject {
  id: ID!

  """The project avatar URL"""
  avatarUrls: JiraAvatarUrls!

  """The project key"""
  key: String!

  """The project name"""
  name: String!

  """The Type of project"""
  projectTypeKey: String!

  """Project category"""
  statusCategory: JiraProjectCategory!
}

type JiraResolution {
  id: ID!

  """Description of the resolution"""
  description: String!

  """Resolution name"""
  name: String!
}

type JiraVersion {
  id: ID!

  """Name of the version"""
  name: String!

  """Is the version archived"""
  archived: Boolean!

  """Is the version released"""
  released: Boolean!

  """Date of the release"""
  releaseDate: String!
}

type JiraVersionEdge {
  """The item at the end of the edge."""
  node: JiraVersion!
}

type JiraVersionConnection {
  """A list of edges."""
  edges: [JiraVersionEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type JiraIssueRemoteLinkEdge {
  """The item at the end of the edge."""
  node: JiraIssue!
}

type JiraIssueRemoteLinkConnection {
  """A list of edges."""
  edges: [JiraIssueRemoteLinkEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type JiraIssueLinkType {
  id: ID!

  """Name of the link"""
  name: String!

  """Name of the inward link"""
  inward: String!

  """Name of the outward link"""
  outward: String!
}

type JiraIssueLink {
  id: ID!

  """Type of link"""
  type: JiraIssueLinkType!

  """This is an outward issue link"""
  outwardIssue: JiraIssue

  """This is an inward issue link"""
  inwardIssue: JiraIssue
}

type JiraIssueLinkEdge {
  """The item at the end of the edge."""
  node: JiraIssueLink!
}

type JiraIssueLinkConnection {
  """A list of edges."""
  edges: [JiraIssueLinkEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type JiraIssueEdge {
  """The item at the end of the edge."""
  node: JiraIssue!
}

type JiraIssueConnection {
  """A list of edges."""
  edges: [JiraIssueEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type JiraPriority {
  id: ID!

  """Priority name"""
  name: String!

  """Priority icon"""
  iconUrl: String!
}

type JiraIssueType {
  id: ID!

  """Name of the type"""
  name: String!

  """Description of the type"""
  description: String!

  """Icon of the type"""
  iconUrl: String!

  """Is it a subtask"""
  subtask: Boolean!
}

type JiraIssue {
  id: ID!

  """Identifies the date and time when the object was created"""
  createdAt: String!

  """Identifies the date and time when the object was closed"""
  closedAt: String

  """Identifies the date and time when the object was last updated"""
  updatedAt: String

  """Date for the end of Support (useful with JIRA Service Desk)"""
  endOfSupport: String

  """URL of the issue to the source Jira instance"""
  url: String

  """The issue assignee"""
  assignee: JiraUser

  """The issue creator"""
  creator: JiraUser!

  """The issue reporter"""
  reporter: JiraUser

  """Issue Key"""
  key: String

  """The issue type"""
  type: JiraIssueType

  """Summary (or title) of the issue"""
  summary: String!

  """Description of the issue"""
  description: String

  """Description of the issue"""
  server: JiraServer

  """Status of the issue"""
  status: JiraStatus

  """Project of the issue"""
  project: JiraProject

  """Resolution of the issue"""
  resolution: JiraResolution

  """A list of fixVersions"""
  fixVersions: JiraVersionConnection

  """A list of Versions"""
  versions: JiraVersionConnection

  """A list of remote links"""
  remoteLinks: JiraIssueRemoteLinkConnection

  """A list of link to other issues"""
  links: JiraIssueLinkConnection!

  """A list of subtasks"""
  subtasks: JiraIssueConnection!

  """Issue key of the parent Epic"""
  parentEpic: String

  """Issue key of the parent Initiative"""
  parentInitiative: String

  """Issue points"""
  points: Float

  """Issue original points"""
  originalPoints: Float

  """Issue priority"""
  priority: JiraPriority
}

type JiraIssueItemConnection {
  nodes: [JiraIssue!]
  totalCount: Int!
}

type JiraIssueBucketWeek {
  """First day of the week"""
  weekStart: String!

  """The number of documents that week"""
  docCount: Float!

  """The number of points that week"""
  sum: Float
}

type JiraIssueActivityBucket {
  """The Bucket key"""
  key: String!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The number of elements in the bucket"""
  docCount: Float!

  """The number of points in the bucket"""
  sum: Float

  """Weeks of activity"""
  weeks: [JiraIssueBucketWeek!]!
}

type JiraIssuesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type CircleciEnvvars {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): CircleciEnvvarsData!

  """Access to configuration values and metadata"""
  config: CircleciEnvvarsConfig!
}

type CircleciEnvvarsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: CircleciEnvvarsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): CircleciEnvvarItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): JiraIssue!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): CircleciEnvvarsAggregationConnection!
}

input CircleciEnvvarsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type CircleciEnvvarsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type EnvvarRepositoryOwner {
  id: ID!

  """The username of the actor."""
  login: String!

  """The HTTP URL for this repository."""
  url: String!
}

type EnvvarRepository {
  id: ID!

  """The name of the repository."""
  name: String

  """The HTTP URL for this repository."""
  url: String!

  """The User owner of the repository."""
  owner: EnvvarRepositoryOwner!
}

type Source {
  id: ID!

  """The source repository."""
  repository: EnvvarRepository
}

type Envvar {
  id: ID!

  """The name of the environment variable"""
  name: String!

  """The value of the environment variable"""
  value: String!

  """Link to the configuration page for this environment variable"""
  url: String!

  """The environment variable source"""
  source: Source!
}

type CircleciEnvvarItemConnection {
  nodes: [Envvar!]
  totalCount: Int!
}

type CircleciEnvvarsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type CircleciPipelines {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): CircleciPipelinesData!

  """Access to configuration values and metadata"""
  config: CircleciPipelinesConfig!
}

type CircleciPipelinesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: CircleciPipelinesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): CircleciPipelineItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): JiraIssue!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): CircleciPipelinesAggregationConnection!
}

input CircleciPipelinesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type CircleciPipelinesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type PipelineError {
  """Type of error"""
  type: String!

  """Message of the error"""
  message: String!
}

type PipelineTriggerActor {
  """Login of the user"""
  login: String!

  """Avatar URL of the user"""
  avatar_url: String
}

type PipelineTrigger {
  """Type of trigger"""
  type: String!

  """Actor who triggered the pipeline"""
  actor: PipelineTriggerActor!
}

type VcsCommit {
  """Body of the commit"""
  body: String!

  """Subject of the commit"""
  subject: String!
}

type Vcs {
  """Origin repository url"""
  origin_repository_url: String!

  """Target repository url"""
  target_repository_url: String!

  """Revision hash"""
  revision: String!

  """Provider Name"""
  provider_name: String!

  """Branch on the repository"""
  branch: String

  """Commit that triggered the pipeline"""
  commit: VcsCommit
}

type Pipeline {
  id: ID!

  """Errors associated with the pipeline"""
  errors: [PipelineError!]!

  """The value of the environment variable"""
  project_slug: String!

  """Pipeline number"""
  number: String!

  """Pipeline state"""
  state: String!

  """Identifies the date and time when the object was created."""
  createdAt: String!

  """The pipeline trigger"""
  trigger: PipelineTrigger!

  """Vcs details associated with the trigger"""
  vcs: Vcs!

  """Identifies the date and time when the object was updated."""
  updatedAt: String!

  """Identifies the date and time when the object was triggered."""
  triggeredAt: String!

  """The environment variable source"""
  source: Source!
}

type CircleciPipelineItemConnection {
  nodes: [Pipeline!]
  totalCount: Int!
}

type CircleciPipelinesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type CircleciInsights {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): CircleciInsightsData!

  """Access to configuration values and metadata"""
  config: CircleciInsightsConfig!
}

type CircleciInsightsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: CircleciInsightsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): CircleciJobsWorkflowRunItemConnection!

  """Returns a single item by providing its ID"""
  item(
    """ID fo an item"""
    id: String!
  ): CircleciJobRun!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): CircleciInsightsAggregationConnection!

  """
  Compare multiple metrics for multiple aggregations (for example, credits spent per week and per job name)
  """
  matrixAggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """Maximum number of buckets to analyze"""
    maxBuckets: String

    """Field to be used for the comparison"""
    compareField: String!

    """Field to aggregate on"""
    field: String!
  ): CirclecInsightsMatrixAggregationsConnection!
}

input CircleciInsightsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type CircleciInsightsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type CircleciMetricsDuration {
  """Max"""
  min: Float

  """Min"""
  max: Float

  """Median"""
  median: Float

  """Mean"""
  mean: Float

  """95th percentile"""
  p95: Float

  """Standard Deviation"""
  standard_deviation: Float
}

type CircleciWorkflowMetrics {
  """Success rate"""
  success_rate: Float

  """Total runs for the workflow"""
  total_runs: Float

  """Number of failed runs"""
  failed_runs: Float

  """Number of successful runs"""
  successful_runs: Float

  """Throughput"""
  throughput: Float

  """Total credits used"""
  total_credits_used: Float

  """Duration metrics for the runs"""
  duration_metrics: CircleciMetricsDuration
}

type CircleciWorkflow {
  id: ID!

  """Name of the workflow"""
  name: String

  """Start of the metrics window"""
  window_start: String!

  """End of the metrics window"""
  window_end: String!

  """The source repository."""
  source: Source
}

type CircleciJob {
  """Name of the workflow"""
  name: String

  """Start of the metrics window"""
  window_start: String!

  """End of the metrics window"""
  window_end: String!

  """Job Metrics"""
  metrics: CircleciWorkflowMetrics

  """Job Workflow"""
  workflow: CircleciWorkflow
}

type CircleciJobRun {
  id: ID!

  """Run started at"""
  started_at: String!

  """Run stopped at"""
  stopped_at: String!

  """Run duration"""
  duration: Float!

  """Run status"""
  status: String!

  """Credits used for the run"""
  credits_used: Float!

  """The job"""
  job: CircleciJob
}

type CircleciJobsWorkflowRunItemConnection {
  nodes: [CircleciJobRun!]
  totalCount: Int!
}

type CirclecInsightsMatrixAggregationsConnection {
  nodes: [AggregationConnection!]
  compareField: String!
  totalCount: Int!
}

type AggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type CircleciInsightsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type TestingStates {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): TestingStatesData!

  """Access to configuration values and metadata"""
  config: TestingStatesConfig!
}

type TestingStatesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: StatesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataStateConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): State!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): StatesAggregationConnection!
}

input StatesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type TestingStatesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type Dependency {
  id: ID!

  """Name of the dependency"""
  name: String!

  """Version of the dependency"""
  version: String

  """Concatenated name and version, separated with a _"""
  full: String!

  """The HTTP URL for this PR."""
  url: String
}

type DependencyEdge {
  """The item at the end of the edge."""
  node: Dependency!
}

type DependencyConnection {
  """A list of edges."""
  edges: [DependencyEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type State {
  id: ID!

  """Date at which the state event was recorded (last)"""
  createdAt: String!

  """Name of the element being tested"""
  name: String!

  """Version of the element being tested"""
  version: String!

  """Concatenated name and version, separated with a _"""
  full: String!

  """List of dependencyes to the element being tested"""
  dependencies: DependencyConnection!

  """State of the test execution (PASS, FAIL, ...)"""
  state: String!

  """The HTTP URL for this PR."""
  url: String!

  """Total number of tests in the run"""
  runTotal: Float!

  """Total number of successful tests in the run"""
  runSuccess: Float!

  """Total number of failed tests in the run"""
  runFailure: Float!

  """Total duration of the run"""
  runDuration: Float!
}

type DataStateConnection {
  nodes: [State!]
  totalCount: Int!
}

type StatesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type TestingRuns {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): TestingRunsData!

  """Access to configuration values and metadata"""
  config: TestingRunsConfig!
}

type TestingRunsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: TestingRunsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): TestingRunsConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): TestingRun!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): TestingRunsAggregationConnection!

  """
  Return an aggregation by a provided timeframe (week, day, month) of the average failure rate
  """
  failurerate(
    """Specify the number of first level buckets to return"""
    buckets: Float = 25

    """Specify the date field to aggregate on"""
    datefield: String = "createdAt"

    """Specify the field to aggregate by (such as plan.name.keyword)"""
    field: String = "name.keyword"

    """Specify the interval for the data histogram (day, week, month, year)"""
    interval: String = "week"
  ): TestingRunsFailureRateConnection!
}

input TestingRunsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type TestingRunsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type TestingRun {
  id: ID!

  """Date at which the state event was recorded (last)"""
  createdAt: String!

  """Name of the element being tested"""
  name: String!

  """Version of the element being tested"""
  version: String!

  """Concatenated name and version, separated with a _"""
  full: String!

  """List of dependencyes to the element being tested"""
  dependencies: DependencyConnection!

  """State of the test execution (PASS, FAIL, ...)"""
  state: String!

  """The HTTP URL for this PR."""
  url: String!

  """Total number of tests in the run"""
  runTotal: Float!

  """Total number of successful tests in the run"""
  runSuccess: Float!

  """Rate of successful tests in the run"""
  runSuccessRate: Float!

  """Total number of failed tests in the run"""
  runFailure: Float!

  """Rate of failed tests in the run"""
  runFailureRate: Float!

  """Total duration of the run"""
  runDuration: Float!
}

type TestingRunsConnection {
  nodes: [TestingRun!]
  totalCount: Int!
}

type FailureRateBucketDate {
  """Start date of each bucket depending of the set interval"""
  dateStart: String!

  """The number of documents that week"""
  docCount: Float!

  """The failure rate (in %) over the bucket window"""
  runFailureRate: Float!

  """The total number of tests that were executed"""
  runTotal: Float!

  """The average number of tests that were executed per run"""
  runTotalAvg: Float
}

type FailureRateBucket {
  """The Bucket key"""
  key: String!

  """The number of elements in the bucket"""
  docCount: Float!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The failure rate (in %) over the entire period"""
  runFailureRate: Float!

  """The total number of tests that were executed"""
  runTotal: Float

  """The average number of tests that were executed per run"""
  runTotalAvg: Float

  """Breakdown of the dataset per the defined interval"""
  buckets: [FailureRateBucketDate!]!
}

type TestingRunsFailureRateConnection {
  """Field used to aggregate on"""
  field: String

  """A list of aggregation buckets"""
  buckets: [FailureRateBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromDateStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toDateStart: String!
}

type TestingRunsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type TestingCases {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): TestingCasesData!

  """Access to configuration values and metadata"""
  config: TestingCasesConfig!
}

type TestingCasesData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: TestingCasesSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): TestingCasesConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): TestingCase!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): TestingCasesAggregationConnection!

  """
  Return an aggregation by a provided timeframe (week, day, month) of the average failure rate
  """
  failurerate(
    """Specify the number of first level buckets to return"""
    buckets: Float = 25

    """Specify the date field to aggregate on"""
    datefield: String = "createdAt"

    """Specify the field to aggregate by (such as plan.name.keyword)"""
    field: String = "name.keyword"

    """Specify the interval for the data histogram (day, week, month, year)"""
    interval: String = "week"
  ): TestingCasesFailureRateConnection!
}

input TestingCasesSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type TestingCasesConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type TestingCase {
  id: ID!

  """Date at which the state event was recorded (last)"""
  createdAt: String!

  """Name of the test case being executed"""
  name: String!

  """Name of the project in which the test case is being executed"""
  project: String!

  """Name of the test suite containing that the test case"""
  suite: String!

  """Jahia version used during the test"""
  jahia: String!

  """Jahia module used during the test"""
  module: String!

  """Concatenated name and version, separated with a _"""
  full: String!

  """List of dependencyes to the element being tested"""
  dependencies: DependencyConnection!

  """State of the test execution (PASS, FAIL, ...)"""
  state: String!

  """The HTTP URL for this PR."""
  url: String!

  """Total duration of the test case"""
  duration: Float!
}

type TestingCasesConnection {
  nodes: [TestingCase!]
  totalCount: Int!
}

type FailureRateCasesBucketDate {
  """Start date of each bucket depending of the set interval"""
  dateStart: String!

  """The number of documents that week"""
  docCount: Float!

  """The failure rate (in %) over the bucket window"""
  caseFailureRate: Float!

  """The total number of tests that were executed"""
  caseTotal: Float!

  """The average number of tests that were executed per case"""
  caseTotalAvg: Float
}

type FailureRateCasesBucket {
  """The Bucket key"""
  key: String!

  """The number of elements in the bucket"""
  docCount: Float!

  """Representation of the key as a string (useful for dates)"""
  keyAsString: String

  """The failure rate (in %) over the entire period"""
  caseFailureRate: Float!

  """The total number of tests that were executed"""
  caseTotal: Float

  """The average number of tests that were executed per case"""
  caseTotalAvg: Float

  """Breakdown of the dataset per the defined interval"""
  buckets: [FailureRateCasesBucketDate!]!
}

type TestingCasesFailureRateConnection {
  """Field used to aggregate on"""
  field: String

  """A list of aggregation buckets"""
  buckets: [FailureRateCasesBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromDateStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toDateStart: String!
}

type TestingCasesAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type TestingPerfs {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): TestingPerfsData!

  """Access to configuration values and metadata"""
  config: TestingPerfsConfig!
}

type TestingPerfsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    """Should the respond include disabled (delete) documents?"""
    includeDisabled: Boolean = false
    orderBy: PerfsSortorder

    """Name of the profile to return, leave empty for all"""
    profileName: String

    """Array of transactions keys to return, * for all"""
    transactions: [String!] = ["Total"]

    """Number if items to return """
    size: Int = 100

    """Return items starting from"""
    from: Int = 0
  ): DataPerfConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return a single profile (a single run within a run)"""
    profileId: String

    """Return items starting from"""
    id: String!
  ): Perf

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): PerfsAggregationConnection!

  """Returns a paginated list of items"""
  average(
    """Array of statistics keys to return"""
    statsKeys: [String!] = ["sampleCount", "errorCount", "errorPct", "meanResTime", "medianResTime", "minResTime", "maxResTime", "pct1ResTime", "pct2ResTime", "pct3ResTime", "throughput"]

    """Query to fetch documents to be used to calculate the averages"""
    averageQuery: String

    """Return a single profile (a single run within a run)"""
    profileId: String
  ): PerfAverage
}

input PerfsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type TestingPerfsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type Resource {
  id: ID

  """Name of the resource"""
  name: String!

  """Size of the resource"""
  size: String

  """Name of the container that was used"""
  image: String!

  """JSON.stringify() of the tfsettings file"""
  tfsettings: String
}

type ResourceEdge {
  """The item at the end of the edge."""
  node: Resource!
}

type ResourceConnection {
  """A list of edges."""
  edges: [ResourceEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Tag {
  id: ID

  """Name of the tag"""
  name: String!
}

type TagEdge {
  """The item at the end of the edge."""
  node: Tag!
}

type TagConnection {
  """A list of edges."""
  edges: [TagEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Statistics {
  """Name of the transaction"""
  transaction: String

  """sampleCount result"""
  sampleCount: Float

  """errorCount result"""
  errorCount: Float

  """errorPct result"""
  errorPct: Float

  """meanResTime result"""
  meanResTime: Float

  """medianResTime result"""
  medianResTime: Float

  """minResTime result"""
  minResTime: Float

  """maxResTime result"""
  maxResTime: Float

  """pct1ResTime result"""
  pct1ResTime: Float

  """pct2ResTime result"""
  pct2ResTime: Float

  """pct3ResTime result"""
  pct3ResTime: Float

  """throughput result"""
  throughput: Float

  """receivedKBytesPerSec result"""
  receivedKBytesPerSec: Float

  """sentKBytesPerSec result"""
  sentKBytesPerSec: Float
}

type PerfRun {
  id: ID

  """Name of the run"""
  name: String!

  """Number of users used for the run"""
  userCount: Float

  """Execution time for the run"""
  duration: Float

  """Statistics coming from JMeter statistics.json file"""
  statistics: [Statistics!]
}

type PerfRunEdge {
  """The item at the end of the edge."""
  node: PerfRun!
}

type PerfRunConnection {
  """A list of edges."""
  edges: [PerfRunEdge!]!

  """Identifies the total count of items in the connection."""
  totalCount: Int!
}

type Platform {
  """Name of the vendor"""
  vendor: String!

  """Tenant/account within the vendor"""
  tenant: String

  """Region in which the run was executed"""
  region: String!
}

type Perf {
  id: ID

  """Full document source as a JSON string"""
  _source: String

  """Name of the element being tested"""
  name: String!

  """Description of the run"""
  description: String

  """Who did the description"""
  description_by: String

  """Date the descruption was added"""
  description_date: String

  """Analysis of the run, written by a team member"""
  analysis: String

  """Who did the analysis"""
  analysis_by: String

  """Date the analysis was performed"""
  analysis_date: String

  """Group set by a user to allow quick filtering"""
  group: String

  """Who did set the group"""
  group_by: String

  """When was the group set"""
  group_date: String

  """Was the run verified and relevant ?"""
  verified: Boolean

  """Who verified therun"""
  verified_by: String

  """Date the run was verified"""
  verified_date: String

  """List of dependencyes to the element being tested"""
  repository: RepositoryConnection!

  """Date at which the performance run was started"""
  startedAt: String!

  """Execution time for the run"""
  duration: Float

  """Value of a single run metric (where relevant)"""
  value: Float

  """Rampup used for the run"""
  rampUp: Float

  """Platform used to run the tests"""
  platform: Platform!

  """List of resources to the element being tested"""
  resources: ResourceConnection!

  """List of tags associated with the run"""
  tags: TagConnection!

  """Runs executed in the tests"""
  runs: PerfRunConnection

  """Run corresponding to the selected profile (provided using profileid)"""
  run: PerfRun!

  """The HTTP URL for this PR."""
  url: String

  """Is the run disabled (removed from the records)"""
  disabled: Boolean

  """Who was the run disabled by"""
  disabled_by: String

  """When was the run disabled"""
  disabled_date: String
}

type PerfRunMetric {
  id: ID

  """Name of the element being tested"""
  name: String!

  """Date at which the performance run was started"""
  startedAt: String!

  """Value of a single run metric (where relevant)"""
  value: Float
}

type PerfAverageAverage {
  id: ID

  """
  Object key in the statistics.json payload (sampleCount, errorCount, minResTime, ...)
  """
  statisticsKey: String!

  """Name of the transaction"""
  transaction: String!

  """Average value for that key in that transaction"""
  value: Float!

  """List of runs used when calculating the average"""
  runs: [PerfRunMetric!]!
}

type PerfAverageValue {
  id: ID

  """Name of the run"""
  name: String!

  """Date at which the performance run was started"""
  startedAt: String!

  """
  Object key in the statistics.json payload (sampleCount, errorCount, minResTime, ...)
  """
  statisticsKey: String!

  """Name of the transaction"""
  transaction: String!

  """Value for that key in that transaction"""
  value: Float!
}

type PerfAverage {
  id: ID

  """List of runs used when calculating the average"""
  runs: [Perf!]!

  """Computed average values per key and transaction"""
  average: [PerfAverageAverage!]!

  """Indidual run metrics per key and per transaction"""
  values: [PerfAverageValue!]!

  """List of available transactions"""
  transactions: [String!]

  """List of available statistics keys"""
  statisticsKeys: [String!]!
}

type DataPerfConnection {
  nodes: [Perf!]
  totalCount: Int!
}

type PerfsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type BambooRuns {
  """Access to the dataset as individual items, aggregations and more"""
  data(
    """Query used to filter down content"""
    query: String
  ): BambooRunsData!

  """Access to configuration values and metadata"""
  config: BambooRunsConfig!
}

type BambooRunsData {
  """Query received as a parameter"""
  query: String!

  """Transformation of the received query in an Elasticsearch query"""
  esQuery: String!

  """Total number of documents matching the query"""
  count: Float!

  """Returns a paginated list of items"""
  items(
    orderBy: RunsSortorder

    """Number if items to return """
    size: Int = 10

    """Return items starting from"""
    from: Int = 0
  ): DataRunConnection!

  """Returns a single item by providing its ID"""
  item(
    """Return items starting from"""
    id: String!
  ): State!

  """Return aggregations (facets)"""
  aggregations(
    """
    Additional options as a stringified object (more details in the documentation)
    """
    aggOptions: String

    """Type of aggregation (default: term)"""
    aggType: String

    """
    Field to aggregate on, using the node as the root object (examples: states, author.login)
    """
    field: String!
  ): RunsAggregationConnection!

  """
  Return an aggregation by a provided timeframe (week, day, month) of the average failure rate
  """
  failurerate(
    """Specify the date field to aggregate on"""
    datefield: String = "startedAt"

    """Specify the number of first level buckets to return"""
    buckets: Float = 25

    """Specify the field to aggregate by (such as plan.name.keyword)"""
    field: String = "plan.name.keyword"

    """Specify the interval for the data histogram (day, week, month, year)"""
    interval: String = "week"
  ): BambooRunsFailureRateConnection!
}

input RunsSortorder {
  direction: OrderDirection!

  """
  Order field (see config aggregations node for a sample of possible values)
  """
  field: String
}

type BambooRunsConfig {
  """Query received as a parameter"""
  query: String!

  """Returns a paginated list of available aggregations"""
  aggregations: ConfigAggregations!

  """Returns the table configuration for this datatype"""
  table: ConfigTable!
}

type BambooProject {
  id: ID!

  """Name of the project"""
  name: String!
}

type BambooPlan {
  id: ID!

  """Name of the plan"""
  name: String!

  """Short key of the plan"""
  shortKey: String!

  """Bamboo project attached to the run"""
  project: BambooProject!
}

type BambooRun {
  id: ID!

  """The key of the run"""
  key: String!

  """Bamboo plan attached to the run"""
  plan: BambooPlan!

  """Date at which the run was started"""
  startedAt: String

  """Date at which the run was completed"""
  completedAt: String

  """Name of the run"""
  name: String!

  """Number of the run"""
  number: Float!

  """Duration of the run in seconds"""
  duration: Float!

  """Total number of tests in the run"""
  runTotal: Float

  """Total number of successful tests in the run"""
  runSuccess: Float

  """Total number of failed tests in the run"""
  runFailure: Float

  """Total number of skipped tests in the run"""
  runSkipped: Float

  """Total number of quarantined tests in the run"""
  runQuarantined: Float

  """State of the run"""
  state: String!

  """Was the run successful"""
  successful: Boolean!
}

type DataRunConnection {
  nodes: [BambooRun!]
  totalCount: Int!
}

type RunsAggregationConnection {
  """The field that was aggregated on"""
  field: String!

  """The ES Query executed to fetch the aggregation"""
  esQuery: String!

  """
  When running a matrix aggregation, the field that was used for the comparison
  """
  compareField: String

  """
  When running a matrix aggregation, the value of the field that was used for the comparison
  """
  compareValue: String

  """A list of aggregation buckets"""
  buckets: [AggregationBucket!]!
}

type BambooRunsFailureRateConnection {
  """Field used to aggregate on"""
  field: String

  """A list of aggregation buckets"""
  buckets: [FailureRateBucket!]!

  """Overall first week (first day of the week) in the aggregated buckets"""
  fromDateStart: String!

  """Overall last week (first day of the week) in the aggregated buckets"""
  toDateStart: String!
}

type Query {
  """Fetch data useful for UI configuration"""
  config: Config!

  """Fetches the currently running API version"""
  version: String!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubPullrequests: GithubPullrequests!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubVulnerabilities: GithubVulnerabilities!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubRepositories: GithubRepositories!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubWatchers: GithubWatchers!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubLabels: GithubLabels!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubMilestones: GithubMilestones!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubProjects: GithubProjects!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubReleases: GithubReleases!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubIssues: GithubIssues!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  githubMavenPoms: GithubMavenPoms!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  jiraIssues: JiraIssues!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  circleciEnvvars: CircleciEnvvars!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  circleciPipelines: CircleciPipelines!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  circleciInsights: CircleciInsights!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  testingStates: TestingStates!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  testingRuns: TestingRuns!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  testingCases: TestingCases!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  testingPerfs: TestingPerfs!

  """Fetch data (items, aggregatiosn) related to the dataset"""
  bambooRuns: BambooRuns!
}

type Mutation {
  """Prevent a testing perfs run from being included in the results"""
  disableTestingsPerfsRuns(username: String = "", id: String!): Perf!

  """Prevent a testing perfs run from being included in the results"""
  enableTestingsPerfsRuns(username: String = "", id: String!): Perf!

  """Mark a testing perf run as unverified"""
  unverifyTestingsPerfsRuns(username: String = "", id: String!): Perf!

  """Mark a testing perf run as verified"""
  verifyTestingsPerfsRuns(username: String = "", id: String!): Perf!

  """Update description and analysis for a run"""
  updateTestingsPerfsRun(analysis: String = null, description: String = null, group: String = "", username: String = "", id: String!): Perf!
}
